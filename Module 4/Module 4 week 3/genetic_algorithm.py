# -*- coding: utf-8 -*-
"""Genetic Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YC1WOQtFiMmvo0KDO2i0ND7E9VX_Ue7B
"""

#bai tap 1#
import numpy as np
import pandas as pd

def load_data_from_file():
    data = pd.read_csv("/content/advertising (2).csv")
    features_X = data[['TV', 'Radio', 'Newspaper']].values
    sales_Y = data['Sales'].values
    return features_X, sales_Y

# Load data
features_X, sales_Y = load_data_from_file()

#bai tap 2#
def create_individual(n=4, bound=10):
    individual = np.random.uniform(-bound / 2, bound / 2, n).tolist()
    return individual

# Test create_individual
individual = create_individual()

#bai tap 3#
def compute_loss(individual):
    theta = np.array(individual)
    X_with_bias = np.hstack([features_X, np.ones((features_X.shape[0], 1))])
    y_hat = X_with_bias.dot(theta)
    loss = np.mean((y_hat - sales_Y) ** 2)
    return loss

def compute_fitness(individual):
    loss = compute_loss(individual)
    fitness_value = 1 / (loss + 1)
    return fitness_value

# Test compute_loss and compute_fitness
loss_value = compute_loss(individual)
fitness_value = compute_fitness(individual)

#bai tap 4#
def crossover(individual1, individual2, crossover_rate=0.9):
    individual1_new = individual1.copy()
    individual2_new = individual2.copy()
    if np.random.rand() < crossover_rate:
        crossover_point = np.random.randint(1, len(individual1))
        individual1_new[crossover_point:], individual2_new[crossover_point:] = \
            individual2[crossover_point:], individual1[crossover_point:]
    return individual1_new, individual2_new

# Test crossover
individual1 = create_individual()
individual2 = create_individual()
crossover_result = crossover(individual1, individual2)

#bai tap 5#
def mutate(individual, mutation_rate=0.05):
    individual_m = individual.copy()
    for i in range(len(individual_m)):
        if np.random.rand() < mutation_rate:
            individual_m[i] += np.random.uniform(-1, 1)
    return individual_m

# Test mutate
mutated_individual = mutate(individual1)

#bai tap 6#
def initialize_population(m, n=4, bound=10):
    population = [create_individual(n, bound) for _ in range(m)]
    return population

# Test initialize_population
population = initialize_population(5)

#bai tap 7#
def selection(sorted_population, m=100):
    index1 = np.random.randint(0, m)
    while True:
        index2 = np.random.randint(0, m)
        if index2 != index1:
            break
    return sorted_population[max(index1, index2)]

# Selection will be used later in GA loop

#bai tap 8#
def create_new_population(old_population, elitism=2, gen=1):
    m = len(old_population)
    sorted_population = sorted(old_population, key=compute_fitness)
    new_population = []
    while len(new_population) < m - elitism:
        parent1 = selection(sorted_population, m)
        parent2 = selection(sorted_population, m)
        child1, child2 = crossover(parent1, parent2)
        new_population.append(mutate(child1))
        new_population.append(mutate(child2))
    new_population += sorted_population[-elitism:]  # Elitism: carry the best individuals
    return new_population, compute_loss(sorted_population[-1])

# Test population creation
new_population, best_loss = create_new_population(population)

#bai tap 9#
def run_GA(n_generations=100, m=600):
    features_X, sales_Y = load_data_from_file()
    population = initialize_population(m)
    losses_list = []
    for gen in range(n_generations):
        population, best_loss = create_new_population(population, elitism=2, gen=gen)
        losses_list.append(best_loss)
    return losses_list

# Run the GA
losses_list = run_GA()

#bai tap 10#
import matplotlib.pyplot as plt

def visualize_loss(losses_list):
    plt.plot(losses_list)
    plt.xlabel('Generations')
    plt.ylabel('Best Loss')
    plt.title('Loss Over Generations')
    plt.show()

# Visualize losses
visualize_loss(losses_list)

#bai tap 11#
def visualize_predict_gt():
    sorted_population = sorted(population, key=compute_fitness)
    theta = np.array(sorted_population[-1])
    estimated_prices = np.dot(np.hstack([features_X, np.ones((features_X.shape[0], 1))]), theta)

    plt.figure(figsize=(10, 6))
    plt.plot(sales_Y, label='Real Sales', color='green')
    plt.plot(estimated_prices, label='Predicted Sales', color='blue')
    plt.xlabel('Samples')
    plt.ylabel('Sales')
    plt.legend()
    plt.show()

# Visualize prediction
visualize_predict_gt()